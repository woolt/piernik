!
! PIERNIK Code Copyright (C) 2006 Michal Hanasz
!
!    This file is part of PIERNIK code.
!
!    PIERNIK is free software: you can redistribute it and/or modify
!    it under the terms of the GNU General Public License as published by
!    the Free Software Foundation, either version 3 of the License, or
!    (at your option) any later version.
!
!    PIERNIK is distributed in the hope that it will be useful,
!    but WITHOUT ANY WARRANTY; without even the implied warranty of
!    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
!    GNU General Public License for more details.
!
!    You should have received a copy of the GNU General Public License
!    along with PIERNIK.  If not, see <http://www.gnu.org/licenses/>.
!
!    Initial implementation of PIERNIK code was based on TVD split MHD code by
!    Ue-Li Pen
!        see: Pen, Arras & Wong (2003) for algorithm and
!             http://www.cita.utoronto.ca/~pen/MHD
!             for original source code "mhd.f90"
!
!    For full list of developers see $PIERNIK_HOME/license/pdt.txt
!

#include "piernik.h"

!> \brief A module with an abstract type created to take out neighbor finding code from cg_level

module cg_list_neighbors

   use cg_list_rebalance, only: cg_list_rebalance_t

   implicit none

   private
   public :: cg_list_neighbors_t

   !>
   !! \brief An abstract type created to take out neighbor finding code from cg_level
   !!
   !! \details Brute-force searching through this%dot%gse for all neighbours,
   !! prolongation/restriction overlaps etc can be quite costly -
   !! like O(this%cnt^2). When we have a list sorted according to Morton/Hilbert
   !! id's we can do a bisection search instead. It will result in massive
   !! speedups on cg_list_neighbors_t%find_neighbors and
   !! cg_level_connected_t%{vertical_prep,vertical_b_prep). It may also simplify
   !! the process of fixing refinement structure in refinement_update::fix_refinement.
   !!
   !! * Non-cartesian decompositions should be handled with the bruteforce way.
   !!   It is possible to optimize  them slightly if we save the numbers found
   !!   during decomposition, but I don't think it is really important.
   !! * Unequal cartesian decompositions should be handled with the bruteforce way.
   !!   It can be optimized too, but the impact of optimization would be similar to
   !!   optimization of non-cartesian decompositions.
   !! * Grids which are larger than AMR::bsize (merged grids, non-block
   !!   decompositions, both not implemented yet) may be referred by several id's
   !!   that correspond with AMR::bsize-d virtual grid pieces.
   !!
   !! Alternatively, construct a searchable oct-tree and provide fast routines for
   !! searching grid pieces covering specified position.
   !<

   type, extends(cg_list_rebalance_t), abstract :: cg_list_neighbors_t
   contains
      procedure          :: find_neighbors                 !< Choose between more general and fast routine for neighbor searching.
      procedure, private :: find_neighbors_SFC             !< Make full description of intra-level communication with neighbors. Approach exploiting strict SFC distribution.
      procedure, private :: find_neighbors_bruteforce      !< Make full description of intra-level communication with neighbors. Brute-force approach.
      procedure, private :: find_ext_neighbors_bruteforce  !< Add corners on the external boundary.
      procedure, private :: print_bnd_list                 !< Print the data generated by find_neighbors for debugging purposes.
   end type cg_list_neighbors_t

contains

!>
!! \brief Choose between more general and fast routine for neighbor searching
!!
!! \details All cg%i_bnd and cg%o_bnd are freshly constructed on a given grid level.
!! * As a result cg%[io]_bnd([xyz]dim) should contain full intra-domain set of
!!   exchanges necessary to update face boundaries. These intra-domain
!!   exchanges may update some corners (when non-cartesian decomposition is in use).
!! * Corner data (cg%[io]_bnd(cor_dim) should cover all remaining intra-domain
!!   corners and edges. It has been separated from face boundaries after a27c945a
!!   because in AMR it is not always possible to update all corners together with
!!   faces by doing a sequence of x-, y- and z-sweeps.
!! * Corner data will cover also external faces and corners when
!!   do_external_corners is true. This may be useful for setups with magnetic
!!   fields that cannot be reconstructed from the data contained in the
!!   computational domain.
!!
!! Possible improvements of performance
!! * merge smaller blocks into larger ones,
!!
!! \todo Write variant of find_neighbors_* routine to achieve previous
!! (pre-a27c945a) performance and maintain correctness on corners on complicated
!! topologies:
!! * Divide the descriptions of communicated regions into 4 categories: X-faces,
!!   Y-faces + XY-corners, Z-faces + [XY]Z-corners, other corners. The other
!!   corners would be non-empty only for some refinement local topologies,
!!   it would certainly be empty on an uniform grid.
!! * When no corners are required, perform simultaneous exchange described by
!!   the three directional categories. Some corners might be set up correctly
!!   by a chance, some might not.
!! * When corners are required, perform sequential exchange described by the
!!   three directional categories and supplement it with communication of
!!   "other corners". The sequence of Isend/Irecv should be as follows:
!!   Isend X-faces, Irecv X-faces, Isend Other_corners, Waitall,
!!   Isend Y-faces, Irecv Y-faces, Waitall,
!!   Isend Z-faces, Irecv Z-faces, Irecv Other_corners, Waitall.
!!
!! Any upgrades of these procedures must correctly cover the following cases
!! * single block on single process with partial or full periodic boundaaries
!! * noncartesian base-level decomposition
!! * cartesian decompositions (both equal and non-equal sizes)
!! * AMR "blocky" decompositions with complex patterns of refinement, including
!!     * concave fine/coarse boundary,
!!     * fine blocks touching each othes only at the corner or edge
!!     * the above cases happening through any periodic boundary
!! Non-convex domains aren't perhaps difficult but we never needed or tested them.
!<

   subroutine find_neighbors(this)

      use constants,  only: PPP_AMR
      use dataio_pub, only: warn, msg
      use global,     only: do_external_corners
      use refinement, only: prefer_n_bruteforce
      use mpisetup,   only: master
      use ppp,        only: ppp_main

      implicit none

      class(cg_list_neighbors_t), intent(inout) :: this !< object invoking type bound procedure

      logical, save :: firstcall = .true.
      character(len=*), parameter :: fn_label = "find_neighbors"

      call ppp_main%start(fn_label, PPP_AMR)

      if (do_external_corners) then
         write(msg, '(3a)') "[cg_list_neighbors:find_neighbors] do_external_corners implemented experimentally (", trim(merge("SFC       ", "bruteforce", this%dot%is_blocky .and. .not. prefer_n_bruteforce)), ")"
         if (master .and. firstcall) call warn(msg)
         firstcall = .false.
      endif

      this%ms%valid = .false.
      if (this%dot%is_blocky .and. .not. prefer_n_bruteforce) then
         call this%find_neighbors_SFC
         call this%find_ext_neighbors_bruteforce
         call this%ms%merge(this)  ! temporarily incompatible with find_ext_neighbors_bruteforce
      else
         call this%find_neighbors_bruteforce
         call this%find_ext_neighbors_bruteforce
         ! calling this%ms%merge(this) here makes sense only for such setups, so in periodic boundaries 2 blocks
         ! covers the domain in at least one direction.
      endif

      call ppp_main%stop(fn_label, PPP_AMR)

#ifdef DEBUG
      call this%print_bnd_list
#endif /* DEBUG */

   end subroutine find_neighbors

!> \brief print the data generated by find_neighbors for debugging purposes

   subroutine print_bnd_list(this)

      use cg_list,    only: cg_list_element
      use constants,  only: LO, HI
      use dataio_pub, only: warn, msg, printinfo, die
      use mpisetup,   only: proc

      implicit none

      class(cg_list_neighbors_t), intent(inout) :: this !< object invoking type bound procedure

      type(cg_list_element), pointer :: cgl
      integer :: d, i

      cgl => this%first
      do while (associated(cgl))
         associate (i_bnd => cgl%cg%i_bnd, o_bnd => cgl%cg%o_bnd)
            do d = lbound(i_bnd, dim=1), ubound(i_bnd, dim=1)
               if (allocated(i_bnd(d)%seg) .neqv. allocated(o_bnd(d)%seg)) call die("[cg_list_neighbors:print_bnd_list] allocated(i_bnd(d)%seg) .neqv. allocated(o_bnd(d)%seg)")
               if (allocated(i_bnd(d)%seg)) then
                  if (size(i_bnd(d)%seg) /= size(o_bnd(d)%seg)) call warn("[cg_list_neighbors:print_bnd_list] size(i_bnd(d)%seg) /= size(o_bnd(d)%seg)")
                  do i = lbound(i_bnd(d)%seg, dim=1), ubound(i_bnd(d)%seg, dim=1)
                     write(msg,'(a,i5,a,i2,a,i4,a,i2,a,i4,2(a,3i6,a,3i6,a,i4,a,i8,l2,a,i8))') "cln:fn+ @", proc, " ^", this%l%id, " gid#", cgl%cg%grid_id, " dir=", d, " #i=", i, " [", i_bnd(d)%seg(i)%se(:, LO), " ]x[ ", i_bnd(d)%seg(i)%se(:, HI), " ] -> @", i_bnd(d)%seg(i)%proc, " %",i_bnd(d)%seg(i)%tag, associated(i_bnd(d)%seg(i)%local), " cnt=", product(i_bnd(d)%seg(i)%se(:, HI) - i_bnd(d)%seg(i)%se(:, LO) + 1), " [ ", o_bnd(d)%seg(i)%se(:, LO), " ]x[ ", o_bnd(d)%seg(i)%se(:, HI), " ] -> @", o_bnd(d)%seg(i)%proc, " %",o_bnd(d)%seg(i)%tag, associated(o_bnd(d)%seg(i)%local), " cnt=", product(o_bnd(d)%seg(i)%se(:, HI) - o_bnd(d)%seg(i)%se(:, LO) + 1)
                     call printinfo(msg, .true.)
                  enddo
               endif
            enddo
         end associate
         cgl => cgl%nxt
      enddo

   end subroutine print_bnd_list

!>
!! \brief Make full description of intra-level communication with neighbors.
!! Approach exploiting strict SFC distribution.
!!
!! \details
!! * Assume that cuboids don't collide (no overlapping grid pieces on same
!!   refinement level are allowed).
!! * Should produce the same (or at least equivalent) set of blocks to be
!!   communicated as find_neighbors_bruteforce, but should be way faster,
!!   especially in massively parallel runs.
!!
!! This approach works best if the grid containers are distributed strictly
!! according to the SFC curve and are sorted. If each of p processes has g
!! grid containers on current level (giving n = p * g grids on the level),
!! the cost should be proportional to (log_2(p)+log_2(g))*g, assuming that we
!! have already sorted array containing most critical information from
!! this%dot%gse
!!
!! OPT: there is an easy way to determine here if the corner updates can be
!! performed by face updates done in a sequence of "sweeps" or not. It is
!! possible even to isolate only those corners that can't be updated with face
!! communication. The question is: will it really matter for AMR communication,
!! when we manage to aggregate separate messages for pairs of processes to a
!! single message? IMO not that much.
!!
!! OPT: To achieve pre-a27c945a performance in uniform-grid simulations we may
!! also implement another variant of find_neighbors_* that looks only for face
!! neighbors (typically 6, in worst case 12, still far less than 26) for levels
!! that are fully covered (or even for levels that are covered by strictly
!! convect, well separated groups of grids).
!<

   subroutine find_neighbors_SFC(this)

      use cg_list,    only: cg_list_element
      use constants,  only: xdim, ydim, zdim, cor_dim, ndims, LO, HI, INVALID, BND_FC
      use dataio_pub, only: die
      use domain,     only: dom
      use gcpa,       only: gcpa_t
      use grid_cont,  only: grid_container
      use mpisetup,   only: proc
      use ordering,   only: SFC_order

      implicit none

      class(cg_list_neighbors_t), intent(inout) :: this !< object invoking type bound procedure

      type(grid_container),  pointer    :: cg      !< grid container that we are currently working on
      type(cg_list_element), pointer    :: cgl
      integer(kind=4)                   :: ix, iy, iz
      integer                           :: lh
      integer(kind=8), dimension(ndims) :: n_off     !< neighbor's offset
      integer(kind=8)                   :: n_id      !< neighbor's id
      integer(kind=4)                   :: n_p       !< neighbor's process
      integer                           :: n_grid_id !< neighbor's grid_id on n_p
      integer                           :: n_dd      !< neighbor's direction
      integer(kind=4)                   :: tag
      integer(kind=8), dimension(xdim:zdim, LO:HI) :: overlap
      type(gcpa_t) :: l_pse

      if (.not. this%dot%is_blocky) call die("[cg_list_neighbors:find_neighbors_SFC] Can work only on regular cartesian decompositions")

      call l_pse%init(this)

      cgl => this%first
      do while (associated(cgl))
         cg => cgl%cg

         if (allocated(cg%i_bnd)) deallocate(cg%i_bnd)
         if (allocated(cg%o_bnd)) deallocate(cg%o_bnd)
         allocate(cg%i_bnd(xdim:cor_dim), cg%o_bnd(xdim:cor_dim))

         ! for all potential neighbors:
         do iz = -dom%D_z, dom%D_z
            do iy = -dom%D_y, dom%D_y
               do ix = -dom%D_x, dom%D_x
                  if (any( [ ix, iy, iz ] /= 0)) then
                     ! find their SFC_id (take care about periodicity)
                     n_off = cg%my_se(:, LO) + [ ix, iy, iz ] * cg%n_b
                     where (dom%periodic) n_off = mod(n_off + this%l%n_d - this%l%off, this%l%n_d) + this%l%off
                     n_id = INVALID
                     if ( all(n_off >= this%l%off            .or. .not. dom%has_dir) .and. &
                          all(n_off <  this%l%off+this%l%n_d .or. .not. dom%has_dir)) then ! it is internal boundary

                        n_dd = INVALID
                        if (count([ix, iy, iz] /= 0) > 1) then
                           n_dd = cor_dim
                        else if (ix /= 0) then
                           n_dd = xdim
                        else if (iy /= 0) then
                           n_dd = ydim
                        else if (iz /= 0) then
                           n_dd = zdim
                        endif
                        if (n_dd == INVALID) call die("[cg_list_neighbors:find_neighbors_SFC] undefined direction")

                        n_id = SFC_order(n_off-this%l%off)
                        call this%dot%find_grid(n_id, n_p, n_grid_id) ! find on what process they may reside
                        if (n_grid_id == INVALID) then ! find if they really occur on that process
                           ! if it not occurs set cg%bnd(d, lh) to BND_FC or BND_MPI_FC
                           lh = LO + (ix + iy + iz + 1)/2 ! -1 => LO, +1 => HI, only valid for count([ix, iy, iz] /= 0) == 1) which implies n_dd /= cor_dim
                           if (n_dd >=xdim .and. n_dd <=zdim) cg%bnd(n_dd, lh) = BND_FC
                        else
                           ! incoming part:
                           tag = cart_uniq_tag([-ix, -iy, -iz], n_grid_id)
                           overlap(:, LO) = max(cg%lhn(:, LO), cg%ijkse(:, LO) + [ ix, iy, iz ] * cg%n_b)
                           overlap(:, HI) = min(cg%lhn(:, HI), cg%ijkse(:, HI) + [ ix, iy, iz ] * cg%n_b)
                           call cg%i_bnd(n_dd)%add_seg(n_p, overlap, tag)
                           if (n_p == proc) cg%i_bnd(n_dd)%seg(ubound(cg%i_bnd(n_dd)%seg, dim=1))%local => l_pse%l_pse(n_grid_id)%p

                           ! outgoing part:
                           tag = cart_uniq_tag([ix, iy, iz], cg%grid_id)
                           overlap(:, LO) = max(cg%ijkse(:, LO), cg%lhn(:, LO) + [ ix, iy, iz ] * cg%n_b)
                           overlap(:, HI) = min(cg%ijkse(:, HI), cg%lhn(:, HI) + [ ix, iy, iz ] * cg%n_b)
                           call cg%o_bnd(n_dd)%add_seg(n_p, overlap, tag)

                        endif
                     endif
                  endif
               enddo
            enddo
         enddo

         cgl => cgl%nxt
      enddo

      call l_pse%cleanup

   contains

      !>
      !! \brief Create unique tag for cg - cg exchange
      !!
      !! \details If we put a constraint that a grid piece can not be smaller
      !! than dom%nb, then total number of neighbours that affect local
      !! guardcells is exactly 3 for AMR, cartesian decomposition with
      !! equal-size blocks. Thus, in each direction we can describe realtive
      !! position as one of three cases:
      !! * LEFT, RIGHT - corner neighbours
      !! * FACE        - face neighbour
      !!
      !! This is a lighter version than the global variant. It can be used with
      !! cartesian or purely blocky decomposition.
      !<
      pure function cart_uniq_tag(ixyz, grid_id)

         use constants, only: xdim, ydim, zdim, I_ONE

         implicit none

         integer(kind=4), dimension(xdim:zdim), intent(in) :: ixyz    ! offset in whole grid blocks
         integer,                               intent(in) :: grid_id ! grid piece id

         integer(kind=4) :: cart_uniq_tag
         integer(kind=4), dimension(xdim:zdim) :: r
         integer(kind=4), parameter :: N_POS=3 ! -1, 0, +1

         r = ixyz + I_ONE ! -1 => LEFT, 0 => FACE, +1 => RIGHT
         cart_uniq_tag = int(((grid_id*N_POS+r(zdim))*N_POS+r(ydim))*N_POS+r(xdim), kind=4)

      end function cart_uniq_tag

   end subroutine find_neighbors_SFC

!>
!! \brief Make full description of intra-level communication with neighbors.
!! Brute-force approach.
!!
!! \details
!! * Assume that cuboids don't collide (no overlapping grid pieces on same
!!   refinement level are allowed)
!!
!! This is very general but also quite slow approach. If each of p processes
!! has g grid containers on current level (giving n = p * g grids on the level),
!! the cost is proportional to p*p*g or n*n/p.
!!
!! Current implementation (commit a27c945a) implies correct update of all
!! corners, even on complicated refinement topologies (concave fine region -
!! convect coarse region or fine regions touching each other only by corners).
!! Previous implementation could correctly fill the corners only on an uniform
!! grid and when boundary exchange was called for x, y and z directions
!! separately. Warning: that change introduces measurable performance degradation!
!! This is caused by the fact that in 3D it is required to make 26 separate
!! exchanges to fill all guardcells (in cg_list_bnd::internal_boundaries), while
!! in previous approach only 6 exchanges were required. Unfortunately the
!! previous approach did not work properly for complicated refinements.
!!
!! \todo consider going back to sweeped boundary exchanges (only 6 neighbours to
!! communicate with) as soon as find_neighbors_SFC is tested enough to be chosen
!! as the only option for AMR 'blocky' grids.
!<

   subroutine find_neighbors_bruteforce(this)

      use cg_list,    only: cg_list_element
      use constants,  only: xdim, ydim, zdim, cor_dim, ndims, LO, HI, BND_MPI_FC, BND_FC
      use domain,     only: dom
      use gcpa,       only: gcpa_t
      use grid_cont,  only: grid_container
      use mpisetup,   only: FIRST, LAST, proc
      use overlap,    only: is_overlap

      implicit none

      class(cg_list_neighbors_t), intent(inout) :: this !< object invoking type bound procedure

      type(grid_container),  pointer                  :: cg      !< grid container that we are currently working on
      type(cg_list_element), pointer                  :: cgl
      integer                                         :: b, id, ix, iy, iz
      integer(kind=4)                                 :: j
      integer(kind=8)                                 :: n_lbnd_face_cells
      integer(kind=4)                                 :: d, dd, hl, lh, tag
      integer(kind=8), dimension(xdim:zdim)           :: per
      integer(kind=8), dimension(xdim:zdim, LO:HI)    :: b_layer, poff, aux
      type :: fmap
         logical, dimension(:,:,:), allocatable       :: map
         integer(kind=8), dimension(xdim:zdim, LO:HI) :: b_layer
      end type fmap
      type(fmap), dimension(xdim:zdim, LO:HI)         :: f
      integer(kind=8), dimension(ndims, LO:HI)        :: box_8   !< temporary storage
      type(gcpa_t) :: l_pse

      call l_pse%init(this)

      cgl => this%first
      do while (associated(cgl))
         cg => cgl%cg

         if (allocated(cg%i_bnd)) deallocate(cg%i_bnd)
         if (allocated(cg%o_bnd)) deallocate(cg%o_bnd)
         allocate(cg%i_bnd(xdim:cor_dim), cg%o_bnd(xdim:cor_dim))

         per(:) = 0
         where (dom%periodic(:)) per(:) = this%l%n_d(:)

         ! Create maps to mark neighbouring face cells
         do d = xdim, zdim
            if (.not. allocated(cg%i_bnd(d)%seg)) allocate(cg%i_bnd(d)%seg(0))
            if (.not. allocated(cg%o_bnd(d)%seg)) allocate(cg%o_bnd(d)%seg(0))
            if (dom%has_dir(d)) then
               do lh = LO, HI
                  hl = LO+HI-lh ! HI for LO, LO for HI
                  f(d, lh)%b_layer(:,:) = cg%my_se(:, :)
                  f(d, lh)%b_layer(d, hl) = f(d, lh)%b_layer(d, lh)          ! interior cell layer, 1 cell thick, without corners
                  allocate(f(d, lh)%map(f(d, lh)%b_layer(xdim,LO):f(d, lh)%b_layer(xdim,HI), &
                       &                f(d, lh)%b_layer(ydim,LO):f(d, lh)%b_layer(ydim,HI), &
                       &                f(d, lh)%b_layer(zdim,LO):f(d, lh)%b_layer(zdim,HI)))
                  f(d, lh)%map = .false.
               enddo
            endif
         enddo
         allocate(cg%i_bnd(cor_dim)%seg(0), cg%o_bnd(cor_dim)%seg(0))

         do j = FIRST, LAST
            do b = lbound(this%dot%gse(j)%c(:), dim=1), ubound(this%dot%gse(j)%c(:), dim=1)
               box_8 = int(cg%lhn, kind=8)
               if (is_overlap(box_8, this%dot%gse(j)%c(b)%se(:,:), per(:))) then                ! identify processes with interesting neighbour data

                  do d = xdim, zdim
                     if (dom%has_dir(d)) then
                        do lh = LO, HI
                           hl = LO+HI-lh ! HI for LO, LO for HI

                           ! First, update the map of faces with neighbours

                           ! create 1-layer thick map of neighbours
                           b_layer = this%dot%gse(j)%c(b)%se
                           b_layer(d, hl) = b_layer(d, hl) - lh+hl  ! move the opposite boundary
                           b_layer(d, lh) = b_layer(d, hl)

                           do id = -1, 1 ! scan through periodic images of the domain
                              if (id == 0 .or. per(d)>0) then
                                 poff = b_layer
                                 poff(d, :) = poff(d, :) + id*per(d)
                                 poff(:, LO) = max(poff(:, LO), f(d, lh)%b_layer(:, LO))
                                 poff(:, HI) = min(poff(:, HI), f(d, lh)%b_layer(:, HI))
                                 ! construct the layer to be send to the _interior_ of neighbouring grid and set the flag map
                                 if (is_overlap(f(d, lh)%b_layer, poff)) &
                                      f(d, lh)%map(poff(xdim,LO):poff(xdim,HI), poff(ydim,LO):poff(ydim,HI), poff(zdim,LO):poff(zdim,HI)) = .true.
                              endif
                           enddo

                           ! Second, describe incoming data
                           b_layer = cg%my_se
                           b_layer(d, hl) = b_layer(d, lh) + (lh-hl)
                           b_layer(d, lh) = b_layer(d, lh) + (lh-hl)*dom%nb ! dom%nb thick layer without corners
                           b_layer(:d-1, LO) = b_layer(:d-1, LO) - dom%nb*dom%D_(:d-1)
                           b_layer(:d-1, HI) = b_layer(:d-1, HI) + dom%nb*dom%D_(:d-1) ! corners added in only one way
                           ! faces and corners are included in y and z direction to minimize number of pieces in non-cartesian grid decompositions

                           ! set up segments to be received
                           do iz = -1, 1 ! scan through all periodic possibilities
                              if (iz == 0 .or. per(zdim)>0) then
                                 do iy = -1, 1
                                    if (iy == 0 .or. per(ydim)>0) then
                                       do ix = -1, 1
                                          if (ix == 0 .or. per(xdim)>0) then
                                             poff = this%dot%gse(j)%c(b)%se
                                             poff(:, LO) = poff(:, LO) + [ ix, iy, iz ] * per(:)
                                             poff(:, HI) = poff(:, HI) + [ ix, iy, iz ] * per(:)
                                             if (is_overlap(b_layer, poff)) then
                                                poff(:, LO) = max(b_layer(:, LO), poff(:, LO))
                                                poff(:, HI) = min(b_layer(:, HI), poff(:, HI))
                                                aux = this%dot%gse(j)%c(b)%se
                                                aux(:, LO) = aux(:, LO) + [ ix, iy, iz ] * per(:)
                                                aux(:, HI) = aux(:, HI) + [ ix, iy, iz ] * per(:)
                                                tag = uniq_tag(cg%my_se, aux, b)
                                                aux = poff
                                                aux(d, :) = aux(d, :) + [ -1, 1 ]
                                                if (is_overlap(cg%my_se, aux)) then
                                                   dd = d
                                                else
                                                   dd = cor_dim
                                                endif
                                                call cg%i_bnd(dd)%add_seg(j, poff, tag)
                                                if (j == proc) cg%i_bnd(dd)%seg(ubound(cg%i_bnd(dd)%seg, dim=1))%local => l_pse%l_pse(b)%p
                                             endif
                                          endif
                                       enddo
                                    endif
                                 enddo
                              endif
                           enddo

                           ! Third, describe outgoing data
                           !> \warning replicated code, see above
                           b_layer = this%dot%gse(j)%c(b)%se
                           b_layer(d, hl) = b_layer(d, lh) + (lh-hl)
                           b_layer(d, lh) = b_layer(d, lh) + (lh-hl)*dom%nb ! dom%nb thick layer without corners
                           b_layer(:d-1, LO) = b_layer(:d-1, LO) - dom%nb*dom%D_(:d-1)
                           b_layer(:d-1, HI) = b_layer(:d-1, HI) + dom%nb*dom%D_(:d-1) ! corners added in only one way
                           ! faces and corners are included in y and z direction to minimize number of pieces in non-cartesian grid decompositions

                           ! set up segments to be send
                           do iz = -1, 1 ! scan through all periodic possibilities
                              if (iz == 0 .or. per(zdim)>0) then
                                 do iy = -1, 1
                                    if (iy == 0 .or. per(ydim)>0) then
                                       do ix = -1, 1
                                          if (ix == 0 .or. per(xdim)>0) then
                                             poff = b_layer
                                             poff(:, LO) = poff(:, LO) + [ ix, iy, iz ] * per(:)
                                             poff(:, HI) = poff(:, HI) + [ ix, iy, iz ] * per(:)
                                             if (is_overlap(poff(:,:), cg%my_se)) then
                                                poff(:, LO) = max(cg%my_se(:, LO), poff(:, LO))
                                                poff(:, HI) = min(cg%my_se(:, HI), poff(:, HI))
                                                aux = cg%my_se
                                                aux(:, LO) = aux(:, LO) - [ ix, iy, iz ] * per(:)
                                                aux(:, HI) = aux(:, HI) - [ ix, iy, iz ] * per(:)
                                                tag = uniq_tag(this%dot%gse(j)%c(b)%se, aux, cg%grid_id)
                                                aux = poff
                                                aux(:, LO) = aux(:, LO) - [ ix, iy, iz ] * per(:)
                                                aux(:, HI) = aux(:, HI) - [ ix, iy, iz ] * per(:)
                                                aux(d, :) = aux(d, :) + [ -1, 1 ]
                                                if (is_overlap(this%dot%gse(j)%c(b)%se, aux)) then
                                                   dd = d
                                                else
                                                   dd = cor_dim
                                                endif
                                                call cg%o_bnd(dd)%add_seg(j, poff, tag)
                                             endif
                                          endif
                                       enddo
                                    endif
                                 enddo
                              endif
                           enddo

                        enddo
                     endif
                  enddo

               endif

            enddo
         enddo

         ! Detect fine-coarse boundaries and update boundary types. When not all
         ! mapped cells are facing neighbours, then we may deal with fine/coarse
         ! boundary (full or partial)
         do d = xdim, zdim
            if (dom%has_dir(d)) then
               do lh = LO, HI
                  n_lbnd_face_cells = count(f(d,lh)%map(:,:,:))
                  if (.not. cg%ext_bnd(d, lh)) then
                     if (n_lbnd_face_cells < size(f(d,lh)%map(:,:,:))) cg%bnd(d, lh) = BND_MPI_FC
                     if (n_lbnd_face_cells == 0)                       cg%bnd(d, lh) = BND_FC
                  endif
                  deallocate(f(d,lh)%map)
               enddo
            endif
         enddo

         cgl => cgl%nxt
      enddo

      call l_pse%cleanup

   end subroutine find_neighbors_bruteforce

!>
!! \brief Add corners on the external boundary
!!
!! \details The chunks here could be find by find_neighbors_bruteforce as well
!! but that would complicate an already not-too-clear routine.
!!
!! This is O(n^2)-class algorithm but in a massively parralel runs we don't
!! expect significant cost here because:
!! * either only small subset of base level may be touching external boundary
!!   or base level is split to just few blocks
!! * we should avoid putting numerous blocks on very high refinement levels
!!   touching the outer boundary in AMR anyway (domain expansion is advised in
!!   such case)
!<

   subroutine find_ext_neighbors_bruteforce(this)

      use cg_list,    only: cg_list_element
      use constants,  only: xdim, ydim, zdim, cor_dim, ndims, LO, HI, I_ONE
      use domain,     only: dom
      use dataio_pub, only: die
      use gcpa,       only: gcpa_t
      use global,     only: do_external_corners
      use mpisetup,   only: FIRST, LAST, proc
      use overlap,    only: is_overlap

      implicit none

      class(cg_list_neighbors_t), intent(inout) :: this !< object invoking type bound procedure

      type(cg_list_element), pointer           :: cgl
      integer(kind=8), dimension(xdim:zdim)    :: per
      integer(kind=4)                          :: j
      integer                                  :: b, ix, iy, iz
      integer(kind=8), dimension(ndims, LO:HI) :: box, box_narrow, e_guard, e_guard_wide, whole_level, poff, aux
      integer(kind=4)                          :: d, hl, lh, m_tag
      type(gcpa_t)                             :: l_pse

      if (.not. do_external_corners) return

      call l_pse%init(this)

      m_tag = max_tag(this)

      whole_level(:, LO) = this%l%off
      whole_level(:, HI) = this%l%off + this%l%n_d - I_ONE

      cgl => this%first
      do while (associated(cgl))

         if (any(cgl%cg%ext_bnd)) then

            if (.not. allocated(cgl%cg%i_bnd) .or. .not. allocated(cgl%cg%o_bnd)) call die("[cg_list_neighbors:find_ext_neighbors_bruteforce] not allocated i_bnd or o_bnd")
            if (any([ubound(cgl%cg%i_bnd), ubound(cgl%cg%o_bnd)] < cor_dim)) call die("[cg_list_neighbors:find_ext_neighbors_bruteforce] no cor_dim allocated")

            ! Beware: a lot of replicated code from find_neighbors_bruteforce

            per(:) = 0
            where (dom%periodic(:)) per(:) = this%l%n_d(:)

            do j = FIRST, LAST
               do b = lbound(this%dot%gse(j)%c(:), dim=1), ubound(this%dot%gse(j)%c(:), dim=1)
                  if (this%l%has_ext_bnd(this%dot%gse(j)%c(b)%se) .and. .not. all(this%dot%gse(j)%c(b)%se == cgl%cg%ijkse)) then

                     ! box: remote cg with all possible guardcells
                     box = this%dot%gse(j)%c(b)%se
                     where (dom%has_dir(:)) box(:, LO) = box(:, LO) - dom%nb
                     where (dom%has_dir(:)) box(:, HI) = box(:, HI) + dom%nb

                     if (is_overlap(int(cgl%cg%lh_out, kind=8), box, per(:))) then  ! there is an overlap between remote block with guardcells and local block expanded by its exclusive external guardcells

                        ! box_narrow: remote cg with (d, lh)-face only guardcells, with corners
                        box_narrow = this%dot%gse(j)%c(b)%se
                        do d = xdim, zdim
                           if (dom%has_dir(d)) then
                              if (this%l%is_ext_bnd(this%dot%gse(j)%c(b)%se, d, LO)) box_narrow(d, LO) = box_narrow(d, LO) - dom%nb
                              if (this%l%is_ext_bnd(this%dot%gse(j)%c(b)%se, d, HI)) box_narrow(d, HI) = box_narrow(d, HI) + dom%nb
                           endif
                        enddo

                        do d = xdim, zdim
                           if (dom%has_dir(d)) then
                              do lh = LO, HI
                                 if (cgl%cg%ext_bnd(d, lh)) then
                                    hl = LO+HI-lh  ! HI for LO, LO for HI

                                    ! e_guard: external guardcells, (d, lh)-face only, with corners
                                    e_guard = cgl%cg%lh_out
                                    e_guard(d, hl) = whole_level(d, lh) + (2*lh-3)  ! 2*lh-3 = [-1, 1] for [LO, HI]

                                    ! e-guard_wide: external guardcells, all at (d, lh), including edges and corners
                                    e_guard_wide = cgl%cg%lhn
                                    e_guard_wide(d, hl) = whole_level(d, lh) + (2*lh-3)

                                    do iz = -1, 1 ! scan through all periodic possibilities
                                       if (iz == 0 .or. per(zdim)>0) then
                                          do iy = -1, 1
                                             if (iy == 0 .or. per(ydim)>0) then
                                                do ix = -1, 1
                                                   if (ix == 0 .or. per(xdim)>0) then

                                                      ! poff: all periodic images of remote cg  with all possible guardcells
                                                      poff(:, LO) = box(:, LO) + [ ix, iy, iz ] * per(:)
                                                      poff(:, HI) = box(:, HI) + [ ix, iy, iz ] * per(:)
                                                      if (is_overlap(e_guard, poff)) then
                                                         aux(:, LO) = max(e_guard(:, LO), poff(:, LO))
                                                         aux(:, HI) = min(e_guard(:, HI), poff(:, HI))
                                                         call cgl%cg%o_bnd(cor_dim)%add_seg(j, aux, m_tag + uniq_tag(this%dot%gse(j)%c(b)%se, aux, cgl%cg%grid_id))
                                                      endif

                                                      poff(:, LO) = box_narrow(:, LO) + [ ix, iy, iz ] * per(:)
                                                      poff(:, HI) = box_narrow(:, HI) + [ ix, iy, iz ] * per(:)
                                                      if (is_overlap(e_guard_wide, poff)) then
                                                         aux(:, LO) = max(e_guard_wide(:, LO), poff(:, LO))
                                                         aux(:, HI) = min(e_guard_wide(:, HI), poff(:, HI))
                                                         call cgl%cg%i_bnd(cor_dim)%add_seg(j, aux, m_tag + uniq_tag(cgl%cg%my_se, aux, b))
                                                         if (j == proc) cgl%cg%i_bnd(cor_dim)%seg(ubound(cgl%cg%i_bnd(cor_dim)%seg, dim=1))%local => l_pse%l_pse(b)%p
                                                      endif
                                                   endif
                                                enddo
                                             endif
                                          enddo
                                       endif
                                    enddo

                                 endif
                              enddo
                           endif
                        enddo

                     endif
                  endif
               enddo
            enddo
         endif

         cgl => cgl%nxt
      enddo

      call l_pse%cleanup

   contains

      !> \brief find maximum value of all tags to safely start tagging with possibly different algorithm

      integer(kind=4) function max_tag(this)

         use cg_list,   only: cg_list_element
         use constants, only: pMAX, I_ZERO
         use mpisetup,  only: piernik_MPI_Allreduce

         implicit none

         class(cg_list_neighbors_t), intent(inout) :: this !< object invoking type bound procedure

         type(cg_list_element), pointer :: cgl
         integer :: i, d

         max_tag = I_ZERO
         cgl => this%first
         do while (associated(cgl))
            associate (i_bnd => cgl%cg%i_bnd, o_bnd => cgl%cg%o_bnd)
               do d = lbound(i_bnd, dim=1), ubound(i_bnd, dim=1)
                  if (allocated(i_bnd(d)%seg)) then
                     do i = lbound(i_bnd(d)%seg, dim=1), ubound(i_bnd(d)%seg, dim=1)
                        max_tag = max(max_tag, i_bnd(d)%seg(i)%tag)
                     enddo
                  endif
                  if (allocated(o_bnd(d)%seg)) then
                     do i = lbound(o_bnd(d)%seg, dim=1), ubound(o_bnd(d)%seg, dim=1)
                        max_tag = max(max_tag, o_bnd(d)%seg(i)%tag)
                     enddo
                  endif
               enddo
            end associate
            cgl => cgl%nxt
         enddo

         call piernik_MPI_Allreduce(max_tag, pMAX)

      end function max_tag

   end subroutine find_ext_neighbors_bruteforce

   !>
   !! \brief Create unique tag for cg - cg exchange
   !!
   !! \details If we put a constraint that a grid piece can not be smaller
   !! than dom%nb, then total number of neighbours that affect local
   !! guardcells is
   !! * 3      for cartesian decomposition (including AMR "blocks")
   !! * 2 to 4 for noncartesian decomposition
   !! * more   for AMR with consolidated blocks (unimplemented yet, not
   !!          compatible with current approach)
   !!
   !! Thus, in each direction we can describe realtive position as one of
   !! four cases, or a bit easier one of five cases:
   !! * FAR_LEFT, FAR_RIGHT - corner neighbours, either touching corner or
   !!                         a bit further away
   !! * LEFT, RIGHT         - partially face, partially corner neighbours
   !! * FACE                - face neighbour (may cover also some corners)
   !!
   !! This version can correctly handle noncartesian decompositions and should
   !! also be correct on cartesia and blocy decompositions.
   !<

   pure function uniq_tag(se, nb_se, grid_id)

      use constants, only: LO, HI, xdim, ydim, zdim, INVALID

      implicit none

      integer(kind=8), dimension(xdim:zdim, LO:HI), intent(in) :: se       ! a grid piece
      integer(kind=8), dimension(xdim:zdim, LO:HI), intent(in) :: nb_se    ! neighboring grid piece
      integer,                                      intent(in) :: grid_id  ! grid piece id

      integer(kind=4) :: uniq_tag
      integer, dimension(xdim:zdim) :: r
      integer :: d
      enum, bind(C)
         enumerator :: FAR_LEFT=0, LEFT, FACE, RIGHT, FAR_RIGHT, N_POS
      end enum

      r = INVALID
      do d = xdim, zdim
         if (nb_se(d, LO) > se(d, HI)) then
            r(d) = FAR_RIGHT
         else if (nb_se(d, HI) < se(d, LO)) then
            r(d) = FAR_LEFT
         else if ((nb_se(d, LO) < se(d, LO)) .and. (nb_se(d, HI) < se(d, HI)) .and. (nb_se(d, HI) >= se(d, LO))) then
            r(d) = LEFT
         else if ((nb_se(d, HI) > se(d, HI)) .and. (nb_se(d, LO) > se(d, LO)) .and. (nb_se(d, LO) <= se(d, HI))) then
            r(d) = RIGHT
         else
            r(d) = FACE
         endif
      enddo
      uniq_tag = int(((grid_id*N_POS+r(zdim))*N_POS+r(ydim))*N_POS+r(xdim), kind=4)

   end function uniq_tag

end module cg_list_neighbors
